---
title: github和hexo的一二三（续）
date: 2016-06-23 23:07:55
tags:
- git
- github
- hexo
- next
categories: 
- 学习
- front-end
- git
---

github和hexo的一二三（续）
===

盲点
---

### 什么是加密？

从阮一峰的博客里学到了很多。  

一类是单钥加密（private key cryptography），一类叫做双钥加密（public key cryptography）。前者的加密和解密过程都用同一套密码，后者的加密和解密过程用的是两套密码。

+ 单钥加密
+ 双钥加密，密钥有两把，一把是公开的公钥，还有一把是不公开的私钥。公钥用来加密信息，私钥用来数字签名。  
双钥加密的原理如下：  
a) 公钥和私钥是一一对应的关系  
b) 所有的（公钥, 私钥）对都是不同的。  
c) 用公钥可以解开私钥加密的信息，反之亦成立。  
d) 同时生成公钥和私钥应该相对比较容易，但是从公钥推算出私钥，应该是很困难或者是不可能的。  

通用的单钥加密算法为DES（Data Encryption Standard）。  
通用的双钥加密算法为RSA（ Rivest-Shamir-Adleman）。

<!--more-->

### 什么是数字签名 & 数字证书

"数字签名"（digital signature）和"数字证书"（digital certificate）到底是什么？

#### 什么是数字签名

1. 假设我们的主人公叫做呵呵哒，呵先生有两把钥匙：公钥、私钥
2. 一天，呵先生把他的公钥送给了他的同事路人甲和小美
3. 现在小美就可以写信*今天的天气真好*，然后经过公钥加密，生成*ASDFWEFVC/asdf*，然后发给咱们的呵先生
4. 呵先生收到这封密信*ASDFWEFVC/asdf*，拿出自己的私钥即可解码回*今天天气真好*。这个过程中只要呵先生自己的私钥不丢失，信件内容就能保证安全性
5. 当呵先生收到小美的信件后，打算回信给小米，这时候呵先生打算使用**数字签名**给自己的信件打个印记。呵先生是这么做的，当他写完回信后，使用 `Hash` 算法生成一段固定长度字符串作为信件的摘要
6. 然后呵先生，再将这个摘要用自己的私钥进行加密，这就是**数字签名**，然后将这个数字签名连同上面的回信一同发给小美
7. 小美在收到呵先生的回信后，先拿到信件上附加的数字签名，使用自己手中的公钥进行解码，获取到一个结果。然后小美再对信件本身进行 `Hash` 运算，将得到的结果与之前的通过数字签名得到的结果进行比较，如果一致就说明该信件未被他人修改过

#### 什么是数字证书

上面只是一种理想状态，如果路人甲起了歪心思......

1. 路人甲首先偷偷打开了小美的电脑，把小美电脑里呵先生的公钥删除，然后换上了自己的公钥。
2. 现在，小美再使用所谓呵先生的公钥，其实已经变成了路人甲的公钥
3. 路人甲这时候就可以冒充呵先生，用自己的私钥来制作**数字签名**，写信给小美，小美会误以为这是呵先生的来信
4. 天网恢恢疏而不漏，慢慢的，小美开始觉得有点不对，怎么信件的文风大变？这时，也许小美就会发现在这套逻辑里存在一个致命问题，那就是她无法确定自己手里的公钥到底是谁的。这时候就只能让公正不阿的公先生——**证书中心（certificate authority，简称CA）**出场了，让 CA 给呵先生的公钥做个认证。
5. CA 用自己的私钥，对呵先生的公钥以及另外一些基本信息进行加密，生成的即**数字证书**
6. 现在呵先生感觉自然棒棒哒，以后再写信给小美，只要在进行数字签名的同时，再附上数字证书就行了
7. 小美收到信后，先用 CA 的公钥解开数字证书，就可以拿到呵先生的公钥，然后再用呵先生的公钥去解开数字签名，最终就可以确认这封信是不是呵先生的亲笔了......

加密啥的，绕了这么大一圈，图个啥呢？

### https 是啥

1. 浏览器向服务器发出加密请求
2. 服务器将网页用自己的密钥进行加密后，连同自己的数字证书一同返给客户端
3. 浏览器的“证书管理器”中有“受信任的根证书颁发机构”列表，客户端在接收到响应后，会在这个列表里查看是否存在解开该服务器数字证书的公钥。有两种错误情况：如果公钥在这个列表里，但是解码后的内容不匹配，说明证书被冒用；如果公钥不在这个列表里，说明这张证书不是受信任的机构所颁发，他的真实性无法确定
4. 如果一切都没问题，浏览器就可以使用服务器的公钥对信息内容进行加密，然后与服务器交换信息（已加密）

### SSH 是啥

SSH 即安全外壳协议，Secure Shell Protocol，它采用公钥加密方式，来保证远程登录的安全性。一般流程如下

1. 远程主机收到用户的登录请求，把自己的公钥发给用户
2. 用户使用这个公钥，将登录密码加密后，发送回来
3. 远程主机用自己的私钥，解码登录密码。如果正确，就通过用户登录

那么，同样的一个问题就出现在大家的眼前，如果判断这个公钥就是远程主机的公钥呢？假如冒出来个路人甲截获了用户的请求，然后把自己的公钥发送给了用户，用户是无法判断这个公钥是不是自己请求服务的，因为不像之前 https协议，SSH 协议是没有 CA 的。

现实情况流程如下

1. 客户访问一个新的远程主机，系统会针对这个行为进行一次提示，内容包括远程主机“公钥指纹”。所谓公钥指纹，是指一般情况下公钥长度都很长（如果采用RSA算法加密，长度1024位），很难进行比对，所以对公钥进行一次 MD5 编码，这样就变成了 128 的指纹，例如：`98:2e:fe:e0:de:9f:23:67:28:c2:42:2d:37:e0:58:4d`，这基本上就能进行比较了
2. 客户通过远程主机的网站，去获取远程主机贴出来的自己的公钥指纹，然后进行比对。如果接受这个公钥就进入**一般流程**中的后续步骤
3. 当公钥被接受后，会存在本地文件里，一般是在 **~/.ssh/known_hosts** 文件内。下次再进行登录，就可在这个文件里进行匹配，从而绕过第一次访问时候的系统提示。除了用户自己的 known_hosts 文件，系统也有一个类似文件，一般是在 **/etc/ssh/ssh_known_hosts**，其实这就是类似于浏览器里的“受信任的根证书颁发机构”列表

再进一步，是否可以避免每次登录都要输入账号密码？  
答案是肯定的，SSH 协议本身提供了**公钥登录**，便可实现这个需求

1. 用户需要先用有自己的公钥，如果没有，可以使用 `ssh-keygen` ，会在 **~/.ssh** 下生成的两个新文件：id_rsa.pub（公钥）和id_rsa（私钥），这就是自己的公钥、私钥对。
2. 将自己的公钥追加到服务器的 **~/.ssh/authorized_keys** 文件中

参考
---
1. [http://www.ruanyifeng.com/blog/2006/12/notes_on_cryptography.html](http://www.ruanyifeng.com/blog/2006/12/notes_on_cryptography.html)
2. [http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)
3. [http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html](http://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html)
4. [http://www.youdzone.com/signature.html](http://www.youdzone.com/signature.html)

