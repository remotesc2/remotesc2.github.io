---
title: Express4xx不懂（三）
date: 2016-06-26 11:28:31
tags:
- express4
- HTTP
- cookie
- session
categories: 
- 学习
- back-end
- node.js
- Express4
---

Express4xx 不懂--cookie & session
===

先巩固下 HTTP 基础
---

### 什么是 HTTP

超文本传输协议，即 HTTP 是一种通信协议，它允许将超文本标记语言（HTML）文档从 Web 服务器传送到客户端的浏览器。

目前我们使用的是 HTTP/1.1 版本

### 浏览器到服务器发生了什么？

当在浏览器输入 URL 后，我们的浏览器给 Web 服务器发送了一个 Request, Web 服务器接到Request 后进行处理，生成相应的 Response，然后发送给浏览器，浏览器解析 Response 中的 HTML，这样我们就看到了网页。

### url 组成

``` url
schema://host[:port#]/path/.../[?query-string][#anchor]
```

scheme ——指定低层使用的协议(例如：http, https, ftp)  
host —— HTTP 服务器的IP地址或者域名  
port# —— HTTP 服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/  
path ——访问资源的路径  
query-string ——发送给http服务器的数据  
anchor —— 锚  

### 状态码

Response 消息中的第一行叫做状态行，由 HTTP 协议版本号，状态码，状态消息三部分组成。  
状态码用来告诉HTTP客户端,HTTP服务器是否产生了预期的Response.

HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别

1XX  提示信息 - 表示请求已被成功接收，继续处理  
2XX  成功 - 表示请求已被成功接收，理解，接受  
3XX  重定向 - 要完成请求必须进行更进一步的处理  
4XX  客户端错误 -  请求有语法错误或请求无法实现  
5XX  服务器端错误 -   服务器未能实现合法的请求  

### HTTP 的无状态性

在讲 cookie 和 session 之前，要先清除一个概念—— HTTP 的无状态性！ RFC 里没有提及，但是从 HTTP 历史以及应用场景，我们可以推测出一些理由：

1. 设计 HTTP 最初的目的是为了提供一种发布和接收HTML页面的方法。那个时候没有动态页面技术，只有纯粹的静态HTML页面，因此根本不需要协议能保持状态；
2. 用户在收到响应时，往往要花一些时间来阅读页面，因此如果保持客户端和服务端之间的连接，那么这个连接在大多数的时间里都将是空闲的，这是一种资源的无端浪费。所以HTTP原始的设计是默认短连接，即客户端和服务端完成一次请求和响应之后就断开TCP连接，服务器因此无法预知客户端的下一个动作，它甚至都不知道这个用户会不会再次访问，因此让HTTP协议来维护用户的访问状态也全然没有必要；
3. 将一部分复杂性转嫁到以HTTP协议为基础的技术之上可以使得HTTP在协议这个层面上显得相对简单，而这种简单也赋予了HTTP更强的扩展能力。事实上，session技术从本质上来讲也是对HTTP协议的一种扩展。

> RFC：Request For Comments（RFC），是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件。目前RFC文件是由 Internet Society（ISOC——因特网社团）赞助发行。基本的互联网通信协议都有在 RFC 文件内详细说明。RFC 文件还额外加入许多的论题在标准内，例如对于互联网新开发的协议及发展中所有的记录。因此几乎所有的互联网标准都有收录在 RFC 文件之中。——来自百度百科

总而言之，HTTP的无状态是由其历史使命而决定的。  

但随着网络技术的蓬勃发展，人们再也不满足于死板乏味的静态 HTML，他们希望 web 应用能动起来，于是客户端出现了脚本和 DOM 技术，HTML 里增加了表单，而服务端出现了 CGI 等等动态技术。

> CGI 又是什么鬼？

正是这种web动态化的需求，给 HTTP 协议提出了一个难题：一个无状态的协议怎样才能关联两次连续的请求呢？也就是说无状态的协议怎样才能满足有状态的需求呢？

此时有状态是必然趋势而协议的无状态性也是木已成舟，因此我们需要一些方案来解决这个矛盾，来保持 HTTP 连接状态，于是出现了 cookie 和 session。  

这里，作者提到了两点特别容易混淆的问题。

1. 无状态性和长连接

	可能有人会问，现在被广泛使用的 HTTP1.1 默认使用长连接，它还是无状态的吗？  
	连接方式和有无状态是完全没有关系的两回事。因为状态从某种意义上来讲就是数据，而连接方式只是决定了数据的传输方式，而不能决定数据。长连接是随着计算机性能的提高和网络环境的改善所采取的一种合理的性能上的优化，一般情况下，web服务器会对长连接的数量进行限制，以免资源的过度消耗。
	
2. 无状态性和session

	Session是有状态的，而HTTP协议是无状态的，二者是否矛盾呢？
	Session和HTTP协议属于不同层面的事物，后者属于ISO七层模型的最高层应用层，前者不属于后者，前者是具体的动态页面技术来实现的，但同时它又是基于后者的。在下文中笔者会分析Servlet/Jsp技术中的session机制，这会使你对此有更深刻的理解。

看完这两点，我发现我就是那种混淆的......

> 长连接又是个啥？之前一说长连接不都是 socket 吗？

cookie
---

cookie 将状态数据保存在客户端。

cookie 是在 RFC2109（已废弃，被RFC2965取代）里初次被描述的，每个客户端最多保持三百个 cookie，每个域名下最多 20 个 Cookie（实际上一般浏览器现在都比这个多，如Firefox是50个），而每个 cookie 的大小为最多4K，不过不同的浏览器都有各自的实现。对于 cookie 的使用，最重要的就是要控制 cookie 的大小，不要放入无用的信息，也不要放入过多信息。

无论使用何种服务端技术，只要发送回的 HTTP 响应中包含如下形式的头，则视为服务器要求设置一个cookie：

``` xml
Set-cookie:name=name;expires=date;path=path;domain=domain
```

支持 cookie 的浏览器都会对此作出反应，即创建 cookie 文件并保存（也可能是内存 cookie），用户以后在每次发出请求时，浏览器都要判断当前所有的cookie中有没有没失效（根据 expires 属性判断）并且匹配了 path 属性的 cookie 信息，如果有的话，会以下面的形式加入到请求头中发回服务端：

``` xml
Cookie: name="zj"; Path="/linkage"
```

服务端的动态脚本会对其进行分析，并做出相应的处理，当然也可以选择直接忽略。

这里牵扯到一个规范（或协议）与实现的问题，简单来讲就是规范规定了做成什么样子，那么实现就必须依据规范来做，这样才能互相兼容，但是各个实现所使用的方式却不受约束，也可以在实现了规范的基础上超出规范，这就称之为扩展了。无论哪种浏览器，只要想提供cookie的功能，那就必须依照相应的RFC规范来实现。所以这里服务器只管发Set-cookie头域，这也是HTTP协议无状态性的一种体现。

需要注意的是，出于安全性的考虑，cookie 可以被浏览器禁用。

session
---

session 将数据保存在服务端。

笔者没有找到相关的RFC，因为session本就不是协议层面的事物。它的基本原理是服务端为每一个session维护一份会话信息数据，而客户端和服务端依靠一个全局唯一的标识来访问会话信息数据。用户访问web应用时，服务端程序决定何时创建session，创建session可以概括为三个步骤：

1. 生成全局唯一标识符（sessionid）；
2. 开辟数据存储空间。一般会在内存中创建相应的数据结构，但这种情况下，系统一旦掉电，所有的会话数据就会丢失，如果是电子商务网站，这种事故会造成严重的后果。不过也可以写到文件里甚至存储在数据库中，这样虽然会增加I/O开销，但session可以实现某种程度的持久化，而且更有利于session的共享；
3. 将session的全局唯一标示符发送给客户端。
问题的关键就在服务端如何发送这个session的唯一标识上。联系到HTTP协议，数据无非可以放到请求行、头域或Body里，基于此，一般来说会有两种常用的方式：cookie和URL重写

	+ Cookie  
	读者应该想到了，对，服务端只要设置Set-cookie头就可以将session的标识符传送到客户端，而客户端此后的每一次请求都会带上这个标识符，由于cookie可以设置失效时间，所以一般包含session信息的cookie会设置失效时间为0，即浏览器进程有效时间。至于浏览器怎么处理这个0，每个浏览器都有自己的方案，但差别都不会太大（一般体现在新建浏览器窗口的时候）；

	+ URL重写  
	所谓URL重写，顾名思义就是重写URL。试想，在返回用户请求的页面之前，将页面内所有的URL后面全部以get参数的方式加上session标识符（或者加在path info部分等等），这样用户在收到响应之后，无论点击哪个链接或提交表单，都会在再带上session的标识符，从而就实现了会话的保持。读者可能会觉得这种做法比较麻烦，确实是这样，但是，如果客户端禁用了cookie的话，URL重写将会是首选。
	
cookie & session 取舍
---

1. 应用场景  
cookie 的典型应用场景是 Remember Me 服务，即用户的账户信息通过 cookie 的形式保存在客户端，当用户再次请求匹配的URL的时候，账户信息会被传送到服务端，交由相应的程序完成自动登录等功能。当然也可以保存一些客户端信息，比如页面布局以及搜索历史等等。
session 的典型应用场景是用户登录某网站之后，将其登录信息放入 session，在以后的每次请求中查询相应的登录信息以确保该用户合法。当然还是有购物车等等经典场景；
2. 安全性  
cookie 将信息保存在客户端，如果不进行加密的话，无疑会暴露一些隐私信息，安全性很差，一般情况下敏感信息是经过加密后存储在 cookie 中，但很容易就会被窃取。而 session 只会将信息存储在服务端，如果存储在文件或数据库中，也有被窃取的可能，只是可能性比 cookie 小了太多。
session 安全性方面比较突出的是存在会话劫持的问题，这是一种安全威胁，这在下文会进行更详细的说明。总体来讲，session的安全性要高于 cookie；
3. 性能  
cookie 存储在客户端，消耗的是客户端的I/O和内存，而 session 存储在服务端，消耗的是服务端的资源。但是 session 对服务器造成的压力比较集中，而 cookie 很好地分散了资源消耗，就这点来说，cookie 是要优于 session的；
4. 时效性  
cookie 可以通过设置有效期使其较长时间内存在于客户端，而 session 一般只有比较短的有效期（用户主动销毁 session 或关闭浏览器后引发超时）；
5. 其他  
cookie 的处理在开发中没有 session 方便。而且 cookie 在客户端是有数量和大小的限制的，而 session 的大小却只以硬件为限制，能存储的数据无疑大了太多。

express框架—— session
---

需要使用到 **express-session**，**express-session** 是基于 express 框架专门用于处理 session 的中间件。session 的认证机制离不开 cookie，所以还需要使用 cookieParser 中间件。

参考
---

1. [http://www.cnblogs.com/shoru/archive/2010/02/19/1669395.html](http://www.cnblogs.com/shoru/archive/2010/02/19/1669395.html)